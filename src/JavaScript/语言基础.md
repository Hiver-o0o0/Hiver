# 语言基础

## 语法

### 区分大小写

ECMAScript 中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。变量test 和变量Test 是两个不同的变量。

### 标识符

所谓标识符，就是变量、函数、属性或函数参数的名称。
* 第一个字符必须是一个字母、下划线（_）或美元符号（$）；
* 剩下的其他字符可以是字母、下划线、美元符号或数字。

按照惯例，标识符使用驼峰大小写形式为最佳实践
```js
  firstSecond
  myCar
  doSomethingImportant
```

### 注释
单行注释和块注释
```js
// 注释

/* 这是多行
注释 */
```

### 严格模式
整个脚本启动严格模式
```js
"use strict";
```
单独指定一个函数在严格模式下执行
```js
function doSomething() {
  "use strict";
}
```

### 语句

ECMAScript 中的语句应以分号结尾。

多条语句可以合并到

## 关键字与保留字

```js
break do in typeof 
case else instanceof var 
catch export new void 
class extends return while 
const finally super with 
continue for switch yield 
debugger function this 
default if throw 
delete import try
```
始终保留
```js
enum
```
严格模式下保留
```js
implements package public 
interface protected static 
let private
```
模块代码中保留:
```js
await
```

## 变量
ECMAScript 变量是松散的，意思是变量可以保存任意类型的数据。
三个关键字可以声明变量 let const var。

### var 关键字
```js
var message = "hi"
```
**1.var 声明作用域**

  >使用var 定义的变量会成为包含他的函数的局部变量。比如，使用var 在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁：
  ```js
   function test () {
     var message = 'hi' // 局部变量
   }
   test()
   console.log(message) // 出错！
  ```
  在函数内部定义变量时省略var操作符，可以创建一个全局变量
  ```js
   function test () {
     message = 'hi' // 全局变量 合法，但不推荐
   }
   test()
   console.log(message) // "hi"
  ```
  去掉var操作符之后，message就变成了全局变量。只要调用一次test()，就会定义这个变量，并且可以在函数外部访问到。
> 虽然可以通过省略var 定义全局变量，但不推荐这么做。在局部作用域中定义的全局变量很难维护，也会造成困惑。因为不能一下子断定省略var是不是有意而为之。

如果定义多个变量，可以在一条语句中用逗号分割每个变量
```js
var message = "hi",
    found = false,
    age = 29;
```

**2.var 声明提升**

使用var 时，下面代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域顶部。
```js
function foo () {
  console.log(age);
  var age = 26;
}
foo();  // undefined
```
之所以不会报错，是因为ECMAScript运行时把它看成等价于如下代码
```js
function foo () {
  var age;
  console.log(age);
  age = 26;
}
foo();  // undefined
```
这就是所谓的 “变量提升”，也就是把所有的变量声明都拉到函数作用域的顶部。反复多次使用var声明同一个变量也没有问题：
```js
function foo () {
  var age = 16;
  var age = 26;
  var age = 36;
  console.log(age);
}
foo();  // 36
```

### let声明

  > let 和 var 最明显的区别是，let 声明的范围是块作用域，而var声明的范围是函数作用域。

```js
if (true) {
  var name = "Matt";
  console.log(name); // Matt
}
console.log(name); // Matt

if (true) {
  let name = "Matt";
  console.log(name); // Matt
}
console.log(name); //  ReferenceError: age 没有定义
```

在这里，age变量之所以不能在if块外部被引用，是因为它的作用域仅限于该快内部。块作用域是函数作用域的子集，因此适用于var 的作用域限制同样适用于let。

let 也不允许同一个作用域出现冗余声明。这样会导致报错：
```js
var name;
var name;

let age;
let age; //  SyntaxError；标识符 age 已经声明过了
```

如果同一个块中没有重复声明一个变量，嵌套使用相同的标识符不会报错。
这是因为JavaScript 引擎会记录用于变量声明的标识符及其所在的块作用域。

```js
var name = "Nicholsa";
console.log(name); // Nicholsa
if (true) {
  var name = 'Matt'
  console.log(name); // Matt
}

let age = 30;
console.log(age); // 30
if (true) {
  let age = 26;
  console.log(age); // 26
}
```

**1. 暂时性死区**

let 与 var 的另一个重要区别，就是let 声明的变量不会在作用域中被提升。
```js
// name 会被提升
console.log(name); // undefined
var name = 'Matt';

// age 不会被提升
console.log(age) // ReferenceError：age 没有定义
let age = 26;
```
在解析代码时，JavaScript引擎也会注意到出现在块后面的let声明，只不过在此之前不能以任何方式来引用未声明的变量。在let之前的执行瞬间被称之为“暂时性死区”，在此阶段引用后面才声明的变量都会抛出ReferenceError。

**2. 全局声明**
与var关键字不同，使用let在全局作用域中声明的变量不会成为window对象的属性（var声明的变量则会）。
```js
var name = 'Matt';
console.log(window.name); // Matt

let age = 26;
console.log(window.age); // undefined
```

不过，let声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为了避免SyntaxError，必须确保页面不会重复声明同一个变量。

**3. 条件声明**
在使用var声明变量时，由于声明会被提升，JavaScript引擎会自动将多余的声明在作用域中顶部合并为一个声明。因为let的作用域是块，所以不可能检查前面是否已经使用let声明过同名变量，同时也不可能在没有声明的情况下声明它。

对于let这个新的ES6声明关键字，不能依赖条件声明模式。这是件好事，因为条件声明是一种反模式，他让程序变得更难理解。

```js
if (true) {
  let age;
}
console.log(age)  // 报错
```

**4.for循环中的let声明**

在let出现之前，for循环定义的迭代变量会渗透到循环体外部：
```js
for (var i = 0; i < 5; ++i) {
  // 循环逻辑
}
console.log(i); // 5
```
改成使用let之后，这个问题就消失了，因为迭代变量的作用域仅限于for循环块内部：
```js
for (let i = 0; i < 5; ++i) {
  // 循环逻辑
}
console.log(i) // ReferenceError: i没有定义
```
在使用var的时候，最常见的问题就是对迭代变量的奇特声明和修改：
```js
for (var i = 0; i < 5; ++i) {
  setTimeout(() => console.log(i), 0)
}
// 你可能会以为输出0、1、2、3、4
// 实际上输出5、5、5、5、5
```
之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5.在之后执行超时逻辑时，所有的i都是同一个变量，因而输出的都是同一个最终值。

而在使用let声明声明迭代变量时，JavaScript引擎在后台会为每个迭代循环声明一个新的迭代变量。每个setTimeout 引用的都是不同的变量实例，所有console.log输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。
```js
for (let i = 0; i < 5; ++i) {
  setTimeout(() => console.log(i), 0)
}
// 会输出0、1、2、3、4
```
这种每次迭代声明一个独立变量实例的行为适用于所有风格的for循环，包括for-in 和 for-of 循环。

### const 声明

const 的行为与let基本相同，唯一一个重要区别是用它声明变量时必须同时初始化变量，且尝试修改const声明的变量会导致运行时错误。

```js
const age = 26;
age = 26; // TypeError: 给常量赋值

// const 也不允许重复声明
const name = 'Matt';
const nale = 'Nicholas'; // SyntaxError

// const 声明的作用于也是块
const name = 'matt';
if (true) {
  const name = 'Nicholas';
}
console.log(name); // Matt
```
const 声明的限制只适用于它指向的变量的引用。换句话说，如果const变量引用的是一个对象，那么修改这个对象内部的属性并不违反const的限制。
```js
const person = {};
person.name = 'Matt'; // ok
```
不能用const来声明迭代变量（因为迭代变量会自增）：
```js
for(const i = 0; i < 10; ++i) {} // TypeError: 给常量赋值
```

### 声明风格及最佳实践
ECMAScript6 增加let和const从客观上为这门语言更精确地声明作用域和语义提供了更好的支持。
1. 不使用var
2. const 优先，let 次之