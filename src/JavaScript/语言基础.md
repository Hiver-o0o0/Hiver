# 语言基础

## 语法

### 区分大小写

ECMAScript 中一切都区分大小写。无论是变量、函数名还是操作符，都区分大小写。变量test 和变量Test 是两个不同的变量。

### 标识符

所谓标识符，就是变量、函数、属性或函数参数的名称。
* 第一个字符必须是一个字母、下划线（_）或美元符号（$）；
* 剩下的其他字符可以是字母、下划线、美元符号或数字。

按照惯例，标识符使用驼峰大小写形式为最佳实践
```js
  firstSecond
  myCar
  doSomethingImportant
```

### 注释
单行注释和块注释
```js
// 注释

/* 这是多行
注释 */
```

### 严格模式
整个脚本启动严格模式
```js
"use strict";
```
单独指定一个函数在严格模式下执行
```js
function doSomething() {
  "use strict";
}
```

### 语句

ECMAScript 中的语句应以分号结尾。

多条语句可以合并到

## 关键字与保留字

```js
break do in typeof 
case else instanceof var 
catch export new void 
class extends return while 
const finally super with 
continue for switch yield 
debugger function this 
default if throw 
delete import try
```
始终保留
```js
enum
```
严格模式下保留
```js
implements package public 
interface protected static 
let private
```
模块代码中保留:
```js
await
```

## 变量
ECMAScript 变量是松散的，意思是变量可以保存任意类型的数据。
三个关键字可以声明变量 let const var。

### var 关键字
```js
var message = "hi"
```
**1.var 声明作用域**

  >使用var 定义的变量会成为包含他的函数的局部变量。比如，使用var 在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁：
  ```js
   function test () {
     var message = 'hi' // 局部变量
   }
   test()
   console.log(message) // 出错！
  ```
  在函数内部定义变量时省略var操作符，可以创建一个全局变量
  ```js
   function test () {
     message = 'hi' // 全局变量 合法，但不推荐
   }
   test()
   console.log(message) // "hi"
  ```
  去掉var操作符之后，message就变成了全局变量。只要调用一次test()，就会定义这个变量，并且可以在函数外部访问到。
> 虽然可以通过省略var 定义全局变量，但不推荐这么做。在局部作用域中定义的全局变量很难维护，也会造成困惑。因为不能一下子断定省略var是不是有意而为之。

如果定义多个变量，可以在一条语句中用逗号分割每个变量
```js
var message = "hi",
    found = false,
    age = 29;
```

**2.var 声明提升**

使用var 时，下面代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域顶部。
```js
function foo () {
  console.log(age);
  var age = 26;
}
foo();  // undefined
```
之所以不会报错，是因为ECMAScript运行时把它看成等价于如下代码
```js
function foo () {
  var age;
  console.log(age);
  age = 26;
}
foo();  // undefined
```
这就是所谓的 “变量提升”，也就是把所有的变量声明都拉到函数作用域的顶部。反复多次使用var声明同一个变量也没有问题：
```js
function foo () {
  var age = 16;
  var age = 26;
  var age = 36;
  console.log(age);
}
foo();  // 36
```

### let声明

  > let 和 var 最明显的区别是，let 声明的范围是块作用域，而var声明的范围是函数作用域。

```js
if (true) {
  var name = "Matt";
  console.log(name); // Matt
}
console.log(name); // Matt

if (true) {
  let name = "Matt";
  console.log(name); // Matt
}
console.log(name); //  ReferenceError: age 没有定义
```

在这里，age变量之所以不能在if块外部被引用，是因为它的作用域仅限于该快内部。块作用域是函数作用域的子集，因此适用于var 的作用域限制同样适用于let。

let 也不允许同一个作用域出现冗余声明。这样会导致报错：
```js
var name;
var name;

let age;
let age; //  SyntaxError；标识符 age 已经声明过了
```

如果同一个块中没有重复声明一个变量，嵌套使用相同的标识符不会报错。
这是因为JavaScript 引擎会记录用于变量声明的标识符及其所在的块作用域。

```js
var name = "Nicholsa";
console.log(name); // Nicholsa
if (true) {
  var name = 'Matt'
  console.log(name); // Matt
}

let age = 30;
console.log(age); // 30
if (true) {
  let age = 26;
  console.log(age); // 26
}
```

**1. 暂时性死区**

let 与 var 的另一个重要区别，就是let 声明的变量不会在作用域中被提升。
```js
// name 会被提升
console.log(name); // undefined
var name = 'Matt';

// age 不会被提升
console.log(age) // ReferenceError：age 没有定义
let age = 26;
```
在解析代码时，JavaScript引擎也会注意到出现在块后面的let声明，只不过在此之前不能以任何方式来引用未声明的变量。在let之前的执行瞬间被称之为“暂时性死区”，在此阶段引用后面才声明的变量都会抛出ReferenceError。

**2. 全局声明**
与var关键字不同，使用let在全局作用域中声明的变量不会成为window对象的属性（var声明的变量则会）。
```js
var name = 'Matt';
console.log(window.name); // Matt

let age = 26;
console.log(window.age); // undefined
```

不过，let声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为了避免SyntaxError，必须确保页面不会重复声明同一个变量。

**3. 条件声明**
在使用var声明变量时，由于声明会被提升，JavaScript引擎会自动将多余的声明在作用域中顶部合并为一个声明。